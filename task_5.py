# ================ task_5.py ================
"""
task_5.py - Модуль для пятого задания в функциональном стиле

Задание 5: Поиск подмассивов с заданной суммой
1. Получить массив чисел
2. Получить целевую сумму
3. Найти все непрерывные подмассивы (последовательные элементы),
   сумма которых равна целевой сумме
4. Подсчитать количество таких подмассивов

Пример:
  Массив: [1, 2, 3, 4]
  Целевая сумма: 3
  Подмассивы: [1, 2] и [3]
  Результат: 2 подмассива

Это классическая задача на использование префиксных сумм,
но здесь реализован простой алгоритм для наглядности.
"""

import logging
from logger import logger
from messages import Messages
from exceptions import ValidationError, CalculationError, AppException

# Получаем сообщения для пятого задания
msgs = Messages["TASK5"]

# ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ==========

input_array_manual_fp = lambda: (
    # Вложенная лямбда для обработки ввода массива
    lambda raw: (
        # Преобразуем строку в список чисел
        list(map(int, raw.split()))
        # Проверяем валидность ввода:
        # 1. Строка не пустая
        # 2. Все элементы - целые числа (разрешены отрицательные)
        if raw.strip() and all(x.lstrip("-").isdigit() for x in raw.split())
        else (_ for _ in ()).throw(
            ValidationError("Введены нецелые числа")
        )
    )
)(input("Введите числа через пробел: ").strip())
"""
Функция для ввода массива чисел.
Пользователь вводит числа через пробел.
Возвращает список целых чисел.
Пример: "1 -2 3 4" → [1, -2, 3, 4]
"""

input_target_sum_fp = lambda: (
    # Вложенная лямбда для обработки ввода целевой суммы
    lambda raw: (
        # Преобразуем строку в целое число
        int(raw) 
        # Проверяем, что строка представляет собой целое число
        # lstrip("-") убирает минус для проверки, что остальное - цифры
        if raw.strip().lstrip("-").isdigit()
        else (_ for _ in ()).throw(
            ValidationError("Целевая сумма должна быть целым числом")
        )
    )
)(input("Введите целевую сумму: ").strip())
"""
Функция для ввода целевой суммы.
Возвращает целое число.
"""

# ========== ОСНОВНОЙ АЛГОРИТМ (вариант 1) ==========

execute_task_5_fp = lambda arr, target_sum: (
    # Если массив пустой, сразу возвращаем 0
    0 if not arr else
    # Используем reduce для подсчета подмассивов
    reduce(
        # Внешний reduce: перебираем все возможные начальные индексы i
        lambda count, i: count + reduce(
            # Внутренний reduce: для данного i перебираем все конечные индексы j
            lambda subcount, j: (
                # Проверяем сумму подмассива arr[i:j+1]
                subcount + 1 if sum(arr[i:j+1]) == target_sum 
                else subcount
            ),
            # Диапазон: от i до конца массива
            range(i, len(arr)),
            0  # Начальное значение для внутреннего reduce
        ),
        # Диапазон: все возможные начальные индексы
        range(len(arr)),
        0  # Начальное значение для внешнего reduce
    )
)
"""
Основная функция для поиска подмассивов (вариант с reduce).
Использует вложенные reduce для функционального стиля.
Параметры:
  arr: массив чисел
  target_sum: целевая сумма
Возвращает:
  Количество подмассивов, сумма которых равна target_sum
Алгоритмическая сложность: O(n²)
"""

# ========== ОСНОВНОЙ АЛГОРИТМ (вариант 2) ==========

execute_task_5_fp_alt = lambda arr, target_sum: sum(
    # Генераторное выражение для подсчета подмассивов
    # Это более питоничный и читаемый способ
    1  # Добавляем 1 для каждого найденного подмассива
    for i in range(len(arr))  # Перебираем все начальные индексы
    for j in range(i, len(arr))  # Для каждого i перебираем все конечные индексы
    if sum(arr[i:j+1]) == target_sum  # Проверяем условие
)
"""
Альтернативная функция для поиска подмассивов.
Использует генераторное выражение, которое более читаемо.
Параметры и возвращаемое значение те же, что и у execute_task_5_fp.
Этот вариант обычно предпочтительнее для Python.
"""

# ========== МЕНЮ ЗАДАНИЯ 5 ==========

def task5_menu_fp():
    """
    Основная функция меню для задания 5.
    Позволяет пользователю искать подмассивы с заданной суммой.
    """
    
    # Состояние программы для задания 5
    # Хранит текущие данные между вызовами меню
    state = {
        "arr": None,     # Исходный массив чисел
        "target": None,  # Целевая сумма для поиска
        "count": None    # Количество найденных подмассивов
    }

    # Словарь действий для меню задания 5
    actions = {
        "1": lambda: (  # Пункт 1: Ввод массива
            # Запрашиваем у пользователя массив чисел
            state.update({"arr": input_array_manual_fp(), "count": None}),
            # Сбрасываем счетчик, так как массив изменился
            logger.info("task5: массив введен")
        ),
        
        "2": lambda: (  # Пункт 2: Ввод целевой суммы
            # Запрашиваем у пользователя целевую сумму
            state.update({"target": input_target_sum_fp(), "count": None}),
            # Сбрасываем счетчик, так как целевая сумма изменилась
            logger.info("task5: целевая сумма введена")
        ),
        
        "3": lambda: (  # Пункт 3: Поиск подмассивов
            # Проверяем, что и массив, и целевая сумма заданы
            (_ for _ in ()).throw(ValidationError("Массив или целевая сумма не заданы"))
            if None in (state["arr"], state["target"]) else
            # Выполняем поиск подмассивов с помощью альтернативного алгоритма
            state.update({"count": execute_task_5_fp_alt(state["arr"], state["target"])}),
            # Сообщаем пользователю об успешном выполнении
            print(msgs["calculation_done"]),
            logger.info("task5: поиск подмассивов выполнен")
        ),
        
        "4": lambda: (  # Пункт 4: Показать результат
            # Проверяем, что поиск был выполнен
            print(msgs["no_data"]) if state["count"] is None else
            (
                # Показываем все введенные данные и результат
                print(f"\nМассив: {state['arr']}"),
                print(f"Целевая сумма: {state['target']}"),
                print(f"Количество подмассивов с суммой {state['target']}: {state['count']}"),
                logger.info("task5: результат показан")
            )
        ),
        
        "5": lambda: (_ for _ in ()).throw(SystemExit),  # Пункт 5: Выход в главное меню
        
        "6": lambda: (  # Пункт 6: Отключить логирование
            logger.setLevel("CRITICAL"),
            print("Логирование отключено"),
            logger.critical("task5: логирование отключено")
        )
    }

    # Основной цикл меню задания 5
    while True:
        # Выводим заголовок меню
        print("\n" + msgs["title"])
        
        # Выводим все пункты меню
        list(map(print, msgs["menu"]))
        
        # Получаем выбор пользователя
        choice = input(msgs["prompt"]).strip()
        
        # Логируем выбор пользователя
        logger.info(f"task5 choice: {choice}")

        try:
            # Пытаемся выполнить действие по выбору пользователя
            actions.get(
                choice,
                # Действие по умолчанию при некорректном выборе
                lambda: (
                    print(msgs["invalid_choice"]),
                    logger.info("task5: неверный пункт меню")
                )
            )()  # Вызываем функцию
            
        except AppException as e:
            # Обрабатываем наши кастомные исключения
            logger.error(str(e))
            print(msgs["input_error"])
            
        except SystemExit:
            # Обрабатываем выход из меню
            logger.info("task5: возврат в главное меню")
            return  # Возвращаем управление в главное меню