# ================ task_1.py ================
"""
task_1.py - Модуль для первого задания в функциональном стиле

Задание 1: Обработка двух массивов
1. Получить два массива чисел (вручную или случайно)
2. Отсортировать первый массив по убыванию
3. Отсортировать второй массив по возрастанию  
4. Сложить соответствующие элементы массивов
5. Если элементы равны - результат равен 0
6. Отсортировать итоговый массив

Этот модуль реализует меню для работы с этим заданием.
"""

# Импортируем необходимые модули
import random  # Для генерации случайных чисел
from functools import reduce  # Функция для свёртки последовательностей
from logger import logger  # Для логирования действий
from messages import Messages  # Текстовые сообщения
from exceptions import (  # Наши кастомные исключения
    InvalidArrayError, EmptyArrayError, ArrayLengthMismatchError, 
    ValidationError, CalculationError, AppException
)

# Получаем сообщения для первого задания из центрального хранилища
msgs = Messages["TASK1"]

# ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ==========

generate_array_fp = lambda size: (
    # Генерируем список случайных чисел заданного размера
    [random.randint(-10, 10) for _ in range(size)]
    # Проверяем, что размер положительный
    if size > 0 else (_ for _ in ()).throw(
        ValidationError("Размер массива должен быть положительным")
    )
    # ^ Если размер <= 0, выбрасываем исключение
    # Конструкция (_ for _ in ()).throw(...) - это функциональный способ
    # выбросить исключение внутри лямбда-выражения
)
"""
Функция для генерации массива случайных чисел.
Параметры:
  size: количество элементов в массиве
Возвращает:
  Список из size случайных чисел от -10 до 10
"""

input_array_manual_fp = lambda: (
    # Вложенная лямбда для обработки ввода
    lambda raw: (
        # Преобразуем строку в список чисел
        list(map(int, raw.split()))
        # Проверяем, что ввод не пустой и все элементы - числа
        if raw.strip() and all(x.lstrip("-").isdigit() for x in raw.split())
        else (_ for _ in ()).throw(
            InvalidArrayError("Введены некорректные числа")
        )
    )
)(input("Введите числа через пробел: ").strip())
"""
Функция для ручного ввода массива.
Запрашивает у пользователя строку чисел, разделенных пробелами.
Возвращает список целых чисел.
Выбрасывает исключение, если ввод некорректен.
"""

# ========== ОСНОВНОЙ АЛГОРИТМ ==========

execute_task_1_fp = lambda arr1, arr2: (
    # Проверка 1: массивы должны быть одинаковой длины
    (_ for _ in ()).throw(ArrayLengthMismatchError(
        f"Массивы должны быть одинаковой длины. Длина первого: {len(arr1)}, второго: {len(arr2)}"
    )) if len(arr1) != len(arr2) else
    # Проверка 2: массивы не должны быть пустыми
    (_ for _ in ()).throw(EmptyArrayError("Массив не может быть пустым")) if not arr1 or not arr2 else
    # Основная логика: если проверки пройдены, выполняем алгоритм
    (
        # Внутренняя лямбда для вычислений
        lambda a, b: (
            # Шаг 1: сортируем итоговый массив
            sorted(
                # Шаг 2: применяем операцию к каждой паре элементов
                list(map(
                    # Лямбда для обработки одной пары элементов
                    lambda x: 0 if x[0] == x[1] else x[0] + x[1],
                    # zip создает пары (a[0], b[0]), (a[1], b[1]), ...
                    zip(a, b)
                ))
            ),
            # Возвращаем также отсортированные массивы для отображения
            a,
            b
        )
    )(sorted(arr1, reverse=True), sorted(arr2))
    # ^ Сначала сортируем первый массив по убыванию, второй по возрастанию
    # ^ Затем передаем их во внутреннюю лямбда-функцию
)
"""
Основная функция для выполнения алгоритма задания 1.
Параметры:
  arr1: первый массив чисел
  arr2: второй массив чисел
Возвращает кортеж:
  (отсортированный_результат, отсортированный_arr1, отсортированный_arr2)
Выбрасывает исключения при ошибках валидации.
"""

# ========== МЕНЮ ЗАДАНИЯ 1 ==========

def task1_menu_fp():
    """
    Основная функция меню для задания 1.
    Реализует интерактивное меню для работы с массивами.
    Использует словарь действий для обработки выбора пользователя.
    """
    
    # Словарь состояния - хранит текущие данные между вызовами действий
    # В функциональном программировании состояние обычно не изменяется,
    # но здесь мы используем его для простоты
    state = {
        "arr1": None,      # Первый массив
        "arr2": None,      # Второй массив
        "sorted1": None,   # Отсортированный первый массив
        "sorted2": None,   # Отсортированный второй массив  
        "result": None     # Результат вычислений
    }

    # Словарь действий - каждая клавиша соответствует функции
    # Этот подход заменяет традиционные if-else или switch-case
    actions = {
        "1": lambda: (  # Ввод массивов вручную
            print("Первый массив:"),
            state.update({"arr1": input_array_manual_fp()}),  # Вводим первый массив
            print("Второй массив:"),
            state.update({"arr2": input_array_manual_fp()}),  # Вводим второй массив
            # Сбрасываем результаты предыдущих вычислений
            state.update({"result": None, "sorted1": None, "sorted2": None}),
            logger.info("task1: массивы введены вручную")  # Логируем действие
        ),
        "2": lambda: (  # Генерация случайных массивов
            # Используем оператор моржа (:=) для сохранения промежуточных значений
            (_size1 := int(input("Размер первого массива: "))),
            (_size2 := int(input("Размер второго массива: "))),
            # Обновляем состояние новыми массивами
            state.update({
                "arr1": generate_array_fp(_size1),
                "arr2": generate_array_fp(_size2),
                "result": None,      # Результат еще не вычислен
                "sorted1": None,     # Сортировки еще не выполнены
                "sorted2": None
            }),
            # Показываем пользователю сгенерированные массивы
            print("Первый массив:", state["arr1"]),
            print("Второй массив:", state["arr2"]),
            logger.info("task1: массивы сгенерированы")
        ),
        "3": lambda: (  # Выполнение алгоритма
            # Проверяем, что массивы заданы
            (_ for _ in ()).throw(ValidationError("Массивы не заданы")) 
            if None in (state["arr1"], state["arr2"]) else
            # Выполняем алгоритм
            (result, sorted1, sorted2 := execute_task_1_fp(state["arr1"], state["arr2"])),
            # Сохраняем результаты в состояние
            state.update({"result": result, "sorted1": sorted1, "sorted2": sorted2}),
            print(msgs["calculation_done"]),  # Сообщаем об успехе
            logger.info("task1: алгоритм выполнен")
        ),
        "4": lambda: (  # Показ результатов
            # Проверяем, что результаты вычислены
            print(msgs["no_data"]) if state["result"] is None else
            (
                # Выводим подробные результаты
                print("\nРезультаты:"),
                print(f"Отсортированный первый массив (по убыванию): {state['sorted1']}"),
                print(f"Отсортированный второй массив (по возрастанию): {state['sorted2']}"),
                print(f"Итоговый массив: {state['result']}"),
                logger.info("task1: результат показан")
            )
        ),
        "5": lambda: (_ for _ in ()).throw(SystemExit),  # Выход в главное меню
        "6": lambda: (  # Отключение логирования
            logger.setLevel("CRITICAL"),  # Устанавливаем самый высокий уровень
            print("Логирование отключено"),
            logger.critical("task1: логирование отключено")  # Последнее сообщение в лог
        )
    }

    # Основной цикл меню задания 1
    while True:
        # Выводим заголовок и пункты меню
        print("\n" + msgs["title"])
        # Функциональный способ вывода всех пунктов меню
        list(map(print, msgs["menu"]))
        
        # Получаем выбор пользователя
        choice = input(msgs["prompt"]).strip()
        logger.info(f"task1 choice: {choice}")

        try:
            # Пытаемся выполнить действие по выбору пользователя
            # get возвращает функцию-действие или функцию по умолчанию
            actions.get(
                choice,  # Ищем действие по ключу
                # Действие по умолчанию: сообщение об ошибке
                lambda: (
                    print(msgs["invalid_choice"]),
                    logger.info("task1: неверный пункт меню")
                )
            )()  # Вызываем найденную функцию
            
        except AppException as e:
            # Обрабатываем наши кастомные исключения
            logger.error(str(e))  # Записываем ошибку в лог
            print(msgs["input_error"])  # Сообщаем пользователю
        except ValueError as e:
            # Обрабатываем ошибки преобразования типов
            logger.error(str(e))
            print("Ошибка ввода числа:", e)
        except SystemExit:
            # Выход из меню задания (возврат в главное меню)
            logger.info("task1: возврат в главное меню")
            return  # Завершаем функцию, возвращаясь в main_fp