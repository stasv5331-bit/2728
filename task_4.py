# ================ task_4.py (исправленная версия) ================
"""
task_4.py - Модуль для четвертого задания в функциональном стиле

Задание 4: Арифметика чисел-массивов
1. Числа представляются как массивы цифр (например, [1, 2, 3] = 123)
2. Поддерживаются операции сложения (+) и вычитания (-)
3. При вычитании результат не может быть отрицательным
4. Результат также представляется как массив цифр

Особенность: работа с числами как с последовательностями цифр,
а не как с целыми числами, что позволяет обрабатывать очень большие числа.
"""

import logging
from logger import logger
from messages import Messages
from exceptions import (
    CalculationError, InvalidArrayError, EmptyArrayError, InvalidNumberError,
    UnsupportedOperationError, NegativeResultError, ValidationError, AppException
)

# Получаем сообщения для четвертого задания
msgs = Messages["TASK4"]

# ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ==========

input_digits_array_fp = lambda: (
    # Вложенная лямбда для обработки ввода цифр
    lambda raw: (
        # Преобразуем строку в список чисел
        list(map(int, raw.split()))
        # Проверяем валидность:
        # 1. Строка не пустая
        # 2. Все элементы - цифры от 0 до 9
        if raw.strip() and all(x.isdigit() and 0 <= int(x) <= 9 for x in raw.split())
        else (_ for _ in ()).throw(
            InvalidNumberError("Все цифры должны быть от 0 до 9")
        )
    )
)(input("Введите цифры через пробел (0-9): ").strip())
"""
Функция для ввода числа в виде массива цифр.
Пользователь вводит цифры через пробел, например: "1 2 3" для числа 123.
Возвращает список целых чисел от 0 до 9.
"""

input_operation_fp = lambda: (
    # Вложенная лямбда для валидации операции
    lambda op: (
        # Возвращаем операцию, если она допустима
        op if op in ['+', '-'] 
        # Иначе выбрасываем исключение
        else (_ for _ in ()).throw(
            UnsupportedOperationError("Операция должна быть '+' или '-'")
        )
    )
)(input("Операция (+ или -): ").strip())
"""
Функция для ввода арифметической операции.
Поддерживаются только сложение (+) и вычитание (-).
Возвращает строку с операцией.
"""

digits_to_number_fp = lambda digits: (
    # Преобразуем массив цифр в число
    # Пример: [1, 2, 3] → "123" → 123
    int(''.join(map(str, digits))) if digits else 0
    # Если массив пустой, возвращаем 0
)
"""
Преобразует массив цифр в целое число.
Параметры:
  digits: список цифр (например, [1, 2, 3])
Возвращает:
  Целое число (например, 123)
"""

number_to_digits_fp = lambda number: (
    # Обработка отрицательных чисел
    ['-'] + [int(d) for d in str(abs(number))] if number < 0 else
    # Обработка нуля
    [0] if number == 0 else
    # Обработка положительных чисел
    [int(d) for d in str(number)]
)
"""
Преобразует целое число в массив цифр.
Параметры:
  number: целое число
Возвращает:
  Список цифр (для отрицательных чисел первый элемент '-')
"""

# ========== ОСНОВНОЙ АЛГОРИТМ (ИСПРАВЛЕННЫЙ) ==========

execute_task_4_fp = lambda arr1, arr2, operation: (
    # Вычисляем числа из массивов цифр
    lambda num1, num2: (
        # Проверяем операцию и валидность для вычитания
        (num1 + num2) if operation == '+' else
        (num1 - num2) if num1 >= num2 else
        (_ for _ in ()).throw(NegativeResultError(
            f"Результат отрицательный: {num1} - {num2}"
        ))
    )(digits_to_number_fp(arr1), digits_to_number_fp(arr2))
)
"""
Основная функция для выполнения арифметических операций.
Параметры:
  arr1: первое число как массив цифр
  arr2: второе число как массив цифр  
  operation: операция '+' или '-'
Возвращает:
  Целое число - результат операции
Выбрасывает исключение, если результат вычитания отрицательный.
"""

# ========== МЕНЮ ЗАДАНИЯ 4 ==========

def task4_menu_fp():
    """
    Основная функция меню для задания 4.
    Позволяет пользователю работать с числами в виде массивов цифр.
    """
    
    # Состояние программы для задания 4
    # Хранит текущие данные между вызовами меню
    state = {
        "arr1": None,      # Первое число как массив цифр (например, [1, 2, 3] для 123)
        "arr2": None,      # Второе число как массив цифр
        "operation": None, # Выбранная операция (+ или -)
        "result": None     # Результат вычислений (массив цифр)
    }

    # Словарь действий для меню задания 4
    # Каждый ключ соответствует пункту меню, значение - функция для выполнения
    actions = {
        "1": lambda: (  # Пункт 1: Ввод первого числа
            # Запрашиваем у пользователя цифры для первого числа
            state.update({"arr1": input_digits_array_fp()}),
            # Показываем пользователю, что ввод успешен
            print(f"Первое число установлено: {state['arr1']}"),
            # Логируем действие для отладки
            logger.info("task4: первое число введено")
        ),
        
        "2": lambda: (  # Пункт 2: Ввод второго числа
            # Аналогично первому пункту, но для второго числа
            state.update({"arr2": input_digits_array_fp()}),
            print(f"Второе число установлено: {state['arr2']}"),
            logger.info("task4: второе число введено")
        ),
        
        "3": lambda: (  # Пункт 3: Ввод операции
            # Запрашиваем у пользователя операцию (только + или -)
            state.update({"operation": input_operation_fp()}),
            print(f"Операция установлена: {state['operation']}"),
            logger.info("task4: операция введена")
        ),
        
        "4": lambda: (  # Пункт 4: Выполнение вычисления
            # Проверяем, что все необходимые данные введены
            # Если какое-то поле None, выбрасываем исключение
            (_ for _ in ()).throw(ValidationError("Не все данные заданы"))
            if None in (state["arr1"], state["arr2"], state["operation"]) else
            # Выполняем вычисление с помощью основного алгоритма
            (result_num := execute_task_4_fp(state["arr1"], state["arr2"], state["operation"])),
            # Преобразуем числовой результат обратно в массив цифр
            state.update({"result": number_to_digits_fp(result_num)}),
            # Сообщаем пользователю об успехе
            print(msgs["calculation_done"]),
            # Логируем успешное выполнение
            logger.info("task4: вычисление выполнено")
        ),
        
        "5": lambda: (  # Пункт 5: Показать результат
            # Проверяем, что результат вычислен
            print(msgs["no_data"]) if state["result"] is None else
            (
                # Показываем все введенные данные и результат
                print(f"\nПервое число: {state['arr1']}"),
                print(f"Второе число: {state['arr2']}"),
                print(f"Операция: {state['operation']}"),
                # Преобразуем массив цифр обратно в читаемую строку
                print(f"Результат: {''.join(map(str, state['result']))}"),
                logger.info("task4: результат показан")
            )
        ),
        
        "6": lambda: (_ for _ in ()).throw(SystemExit),  # Пункт 6: Выход в главное меню
        # Хитрый трюк: создаем пустой генератор и сразу выбрасываем исключение SystemExit
        # Это позволяет выйти из текущего меню
        
        "7": lambda: (  # Пункт 7: Отключить логирование
            # Устанавливаем уровень логирования на CRITICAL (самый высокий)
            # Это означает, что будут записываться только критические ошибки
            logger.setLevel("CRITICAL"),
            print("Логирование отключено"),
            # Записываем последнее сообщение об отключении логирования
            logger.critical("task4: логирование отключено")
        )
    }

    # Основной цикл меню задания 4
    # Работает до тех пор, пока пользователь не выберет выход (пункт 6)
    while True:
        # Выводим заголовок меню
        print("\n" + msgs["title"])
        
        # Выводим все пункты меню
        # Используем функциональный подход: map применяет print к каждому пункту
        list(map(print, msgs["menu"]))
        
        # Запрашиваем выбор пользователя
        choice = input(msgs["prompt"]).strip()
        
        # Логируем выбор пользователя для отладки
        logger.info(f"task4 choice: {choice}")

        try:
            # Пытаемся выполнить действие, соответствующее выбору пользователя
            # Метод get словаря ищет действие по ключу (выбору пользователя)
            # Если ключ не найден, выполняется действие по умолчанию
            actions.get(
                choice,  # Ключ для поиска в словаре действий
                
                # Действие по умолчанию (если выбор не распознан)
                lambda: (
                    # Выводим сообщение об ошибке
                    print(msgs["invalid_choice"]),
                    # Логируем некорректный выбор
                    logger.info("task4: неверный пункт меню")
                )
            )()  # Вызываем найденную функцию (скобки в конце важны!)
            
        except AppException as e:
            # Обрабатываем наши кастомные исключения
            # Это могут быть ошибки ввода, валидации, вычислений и т.д.
            logger.error(str(e))  # Записываем ошибку в лог
            print(msgs["input_error"])  # Показываем пользователю общее сообщение об ошибке
            
        except SystemExit:
            # Обрабатываем выход из меню (при выборе пункта 6)
            logger.info("task4: возврат в главное меню")
            return  # Завершаем функцию, возвращая управление в main_fp


if __name__ == "__main__":
    # Тестовый запуск модуля
    task4_menu_fp()