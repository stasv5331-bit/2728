# ================ main.py ================
"""
main.py - Главный модуль приложения, точка входа в программу

Этот модуль реализует главное меню приложения в функциональном стиле.
Здесь пользователь выбирает, какое задание выполнить, и программа
перенаправляет его в соответствующий модуль.
"""

# Импортируем необходимые модули
from logger import logger  # Для записи действий пользователя
from task_1 import task1_menu_fp  # Меню первого задания
from task_4 import task4_menu_fp  # Меню четвертого задания  
from task_5 import task5_menu_fp  # Меню пятого задания
from messages import Messages  # Текстовые сообщения для интерфейса

# Функция для красивого вывода меню на экран
# Использует функциональный подход: map для вывода всех пунктов
print_menu = lambda msgs: (
    print("\n" + msgs["title"]),  # Сначала выводим заголовок меню
    list(map(print, msgs["options"]))  # Затем все пункты меню один за другим
)

def show_help():
    """
    Показывает пользователю справку по доступным командам.
    Эта функция вызывается при выборе 'h' в главном меню.
    """
    print("\n=== СПРАВКА ===")
    print("1 - Обработка двух массивов (сортировка и поэлементное сложение)")
    print("4 - Арифметические операции над числами в виде массивов")
    print("5 - Поиск подмассивов с заданной суммой")
    print("h - Показать эту справку")
    print("l - Изменить уровень логирования")
    print("0 - Выйти из программы")
    # Записываем в лог, что пользователь запросил справку
    logger.info("Показана справка")

def change_logging_level():
    """
    Позволяет пользователю изменить уровень детализации логов.
    Это полезно для отладки или уменьшения количества записей в лог-файле.
    """
    print("\n=== Изменение уровня логирования ===")
    print("Доступные уровни:")
    print("1. DEBUG - все сообщения")  # Самый подробный уровень
    print("2. INFO - информационные сообщения")  # Стандартный уровень
    print("3. WARNING - только предупреждения")  # Только проблемы
    print("4. ERROR - только ошибки")  # Только критические ситуации
    print("5. CRITICAL - только критические ошибки")  # Минимальная детализация
    
    # Получаем выбор пользователя
    choice = input("Выберите уровень (1-5): ").strip()
    
    # Сопоставляем цифру с названием уровня логирования
    level_map = {
        '1': 'DEBUG',    # Уровень 1 соответствует DEBUG
        '2': 'INFO',     # Уровень 2 соответствует INFO  
        '3': 'WARNING',  # И так далее...
        '4': 'ERROR',
        '5': 'CRITICAL'
    }
    
    if choice in level_map:
        # Меняем уровень логирования
        logger.setLevel(level_map[choice])
        # Сообщаем пользователю об успешном изменении
        print(f"Уровень логирования изменен на: {level_map[choice]}")
        # Записываем это событие в лог
        logger.info(f"Уровень логирования изменен на: {level_map[choice]}")
    else:
        # Если пользователь ввел неправильную цифру
        print("Неверный выбор уровня")
        logger.warning("Неверный выбор уровня логирования")

def main_fp():
    """
    Основная функция приложения в функциональном стиле.
    Содержит бесконечный цикл главного меню, который работает до выхода пользователя.
    """
    # Записываем в лог факт запуска программы
    logger.info("Программа запущена")
    
    # Приветственное сообщение
    print("=" * 60)
    print("ПРОГРАММА ДЛЯ ВЫПОЛНЕНИЯ ЗАДАНИЙ ПО РАБОТЕ С МАССИВАМИ")
    print("=" * 60)

    # Словарь, связывающий выбор пользователя с соответствующими действиями
    # Каждый ключ - это символ, который может ввести пользователь
    # Каждое значение - это функция (лямбда), которая выполняется при выборе
    main_actions = {
        "1": lambda: (  # При выборе "1" переходим в задание 1
            logger.info("→ Переход в task_1"),  # Логируем переход
            task1_menu_fp()  # Запускаем меню первого задания
        ),
        "4": lambda: (  # При выборе "4" переходим в задание 4
            logger.info("→ Переход в task_4"),
            task4_menu_fp()
        ),
        "5": lambda: (  # При выборе "5" переходим в задание 5
            logger.info("→ Переход в task_5"),
            task5_menu_fp()
        ),
        "h": lambda: show_help(),  # При выборе "h" показываем справку
        "l": lambda: change_logging_level(),  # При выборе "l" меняем уровень логирования
        "0": lambda: (_ for _ in ()).throw(SystemExit)  # Хитрый способ выйти из программы
        # ^ Эта конструкция создает генератор и сразу выбрасывает исключение SystemExit
        # Это функциональная альтернатива команде exit()
    }

    # Основной цикл программы - работает до тех пор, пока пользователь не выберет выход
    while True:
        # Получаем сообщения для главного меню из центрального хранилища
        main_msgs = Messages["MENU_MAIN"]
        
        # Выводим меню на экран
        print_menu(main_msgs)
        
        # Получаем выбор пользователя, приводим к нижнему регистру и убираем пробелы
        choice = input(main_msgs["prompt"]).strip().lower()
        
        # Записываем выбор пользователя в лог
        logger.info(f"Главное меню: ввод пользователя → {choice}")

        try:
            # Пытаемся выполнить действие, соответствующее выбору пользователя
            # Если выбор не найден в словаре, выполняем функцию по умолчанию
            main_actions.get(
                choice,  # Ищем действие по ключу (выбору пользователя)
                # Функция по умолчанию, если ключ не найден:
                lambda: (
                    print(main_msgs["invalid"]),  # Выводим сообщение об ошибке
                    logger.warning("Main: неверный пункт меню")  # Логируем ошибку
                )
            )()  # Вызываем найденную функцию (скобки в конце)
            
        except SystemExit:
            # Если было выброшено исключение SystemExit (при выборе "0")
            print("Выход из программы...")
            logger.info("Приложение завершено пользователем")
            break  # Выходим из цикла, завершая программу

# Стандартная проверка для точки входа в программу
# Этот код выполняется только при прямом запуске этого файла
if __name__ == "__main__":
    main_fp()  # Запускаем главную функцию